
    pub fn obtener_pagina_v3(&self, from_index: u64, limit: u64) -> Vec<Meta>  {
        // no estoy segyri de como convierte  de U128 a u128
      /*   let start_index: u128 = Some(from_index).map(|v| v as u128).unwrap_or_default();
        let limit = Some(limit).map(|v| v as usize).unwrap_or(usize::MAX);
        let inicioPag = start_index as usize * limit; */

        let mut vectMEta = vec![];
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        //let mut counter: usize = from_index;
        log!("  from  -> : {},to -> {}",&from_index,&limit);
        let mut _tokfound =from_index;  //0
        let totoal =  self.get_on_total_toks();
                log!(" {}" ,&totoal);
            for x in from_index..limit { 
                
                if  x>= totoal.clone() {
                    break;
                }
                    let mut token =self.get_token(x.to_string().clone());
                /*     log!("  x -> : {},token {}",&x,&token.token_id );
                  */   log!("  token -> : {:?}",token.token_id.clone() );
                 
                    if token.on_sale{
                        
                    vectMEta.push(token  );
                    _tokfound+=1;
                    
                }
                if x== limit {
                    break;
                }
                
                //if( x == limit ){break; }           
            }
            if vectMEta.len()< 12 && limit < totoal {
                let  newfrom =limit; //12
                let  newlimit = limit+30; //24
               
                for y in newfrom..newlimit { 
                 let mut token =self.get_token(y.to_string().clone());
                 log!("  2da vuetla token -> : {:?}",&y );
                     if token.on_sale{
                         
                        vectMEta.push(token  );
                        _tokfound+=1;
                        
                    }
                     if y== newlimit {
                        break;
                    }

                }
            }
           
            vectMEta
         
    }
    pub fn obtener_pagina_v3_by_filtros(&self, from_index: u64, limit: u64,culture: String,country:String) -> Vec<Meta>  {
    
        //Creamos un vector vacio
        let mut vectMEta = vec![];
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        //let mut counter: usize = from_index;
        log!("  from  -> : {},to -> {},cul ->{},coun ->{} ",&from_index,&limit,&culture,&country);
        let mut _tokfound =from_index;  //0
        let mut reg =0;
        //obtenemos el total de tokens existente
        let totoal =  self.get_on_total_toks();
                log!(" {}" ,&totoal);
             //   hacemos un ciclo desde el indice hasta un limite
            for x in from_index..limit { 
                //si el ciclo va llega al ultimo token disponible sale de este
                if  x>= totoal.clone() {
                    break;
                }
                //obtener el token
                    let mut token =self.get_token(x.to_string().clone());
                
                 //si el token esta a lavente agregar al vect
                 //si los filtros country y culture estan en null
                    if token.on_sale.clone() && culture =="null" && country =="null" {
                            
                        vectMEta.push(token  );
                        _tokfound+=1;
                        reg+=1;
                    }
                 //si    country es diferente de null y culture esta en null
                    else if token.on_sale.clone()  && culture !="null" && country =="null"  {
                        if token.culture == culture{
                            vectMEta.push(token  );
                            _tokfound+=1;
                            reg+=1;
                        }    
                        
                        
                    }
                    //si  country es null y culture es diferente de null
                    else if token.on_sale.clone()  && culture =="null" && country !="null"  {
                        if token.country == country{
                            vectMEta.push(token  );
                            _tokfound+=1;
                            reg+=1;
                        }    
                        
                        
                    }
                    //si los filtros country es diferente de null y culture esta en null
                    else if token.on_sale.clone()  && culture !="null" && country !="null" {
                            
                        if token.culture == culture && token.country == country {
                            vectMEta.push(token  );
                            _tokfound+=1;
                            reg+=1;
                        }  
                        
                    }
                //si el ciclo es igual al limite sale de este
                if x== limit {
                    break;
                }
                
                //if( x == limit ){break; }           
            }
               /*  if vectMEta.len()< 12 && limit < totoal {
                    let  newfrom =limit; //12
                    let  newlimit = limit+30; //24
                
                    for y in newfrom..newlimit { 
                    let mut token =self.get_token(y.to_string().clone());
                    log!("  2da vuetla token -> : {:?}",&y );
                        if token.on_sale{
                            
                            vectMEta.push(token  );
                            _tokfound+=1;
                            
                        }
                        if y== newlimit {
                            break;
                        }

                    }
                } */
           
            log!("  registros  -> : {} ",&reg);
            vectMEta
         
    }
    pub fn obtener_pagina_v3_auction(&self, from_index: u64, limit: u64) -> Vec<Meta>  {
        let mut vectMEta = vec![];
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        //let mut counter: usize = from_index;
       // log!("  from  -> : {},to -> {}",&from_index,&limit);
        let mut _tokfound =from_index;  //0
        let totoal =  self.get_on_total_toks()-1;
                log!(" {}" ,&totoal);
            for x in from_index..limit { 
                if x== limit {
                    break;
                }
                if  x>= totoal.clone() {
                    break;
                }
                    let mut token =self.get_token(x.to_string().clone());
                 
                    if token.on_auction{
                        
                    vectMEta.push(token  );
                    _tokfound+=1;
                    
                }
               
                
               
            }
            if vectMEta.len()< 12 && limit < totoal {
                let  newfrom =limit; //12
                let  newlimit = limit+30; //24
               
                for y in newfrom..newlimit { 
                 let mut token =self.get_token(y.to_string().clone());
              //   log!("  2da vuetla token -> : {:?}",&y );
                     if token.on_auction{
                         
                        vectMEta.push(token  );
                        _tokfound+=1;
                        
                    }
                     if y== newlimit {
                        break;
                    }

                }
            }
           
            vectMEta
         
    }

    
    pub fn obtener_pagina_v4_on_auction(&self) -> Vec<Meta>  {
      
        let mut vectMEta = vec![];
      
       
        let totoal =  self.get_on_total_toks();
        log!("  brakes here  -> : {}",&totoal );
            for x in 0..totoal { 
           
                if x == totoal { break; } 
              
                 let mut token =self.get_token(x.to_string().clone());
            /*    
                log!("  token -> : {:?}",token.token_id.clone() );
             */    
                if token.on_auction{
                        vectMEta.push(token  );
                }
           }
            vectMEta
         
    }

  pub fn obtener_pagina_v4(&self, from_index: u64, limit: u64) -> Vec<Meta>  {
      
        let mut vectMEta = vec![];
        assert_ne!(limit, 0, "Cannot provide limit of 0.");  //0 //30 -> 30:45
        //let mut counter: usize = from_index;                //46 //30 -> 30:89                      
        log!("  from  -> : {},to -> {}",&from_index,&limit);
        let mut _tokfound =0;  //0
        let totoal =  self.get_on_total_toks()-1;
                log!(" {}" ,&totoal);
            for x in from_index..totoal { 
                
                if  x>= totoal.clone() { //0 ->150   //29-> 150
                    break;
                }
                    let mut token =self.get_token(x.to_string().clone());
               
                 
                    if token.on_sale{
                        
                    vectMEta.push(token  );
                    _tokfound+=1;
                    
                     }
                if _tokfound== limit {  //1 <30  //30-30
                    break;
                }
                
                          
            }
            
           
            vectMEta
         
    }
    